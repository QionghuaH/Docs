1.设有说明语句:char a='\72';则变量 a（）。
  A.包含1个字符
  B.包含2个字符
  C.包含3个字符
  D.说明不合法
  正确答案：A  反斜杠能转义的八进制和十六进制的字符,\后跟1-3位的八进制数,\x后跟一个或多个十六进制数
2.C语言中，函数值类型的定义可以缺省，此时函数值的隐含类型是（）。
  A.void
  B.int
  C.float
  D.double
  正确答案：A
3.下列程序段的输出结果为（）。
  int a=7,b=9,t;
  t=a*=a>b?a:b;
  printf("%d",t);
  A.7
  B.9
  C.63
  D.49
  正确答案：C  a>b?a:b=9 a=a*7 t=a=63
 4.以下表达式选择结果。（    ）
  std::string str1("trend");
  std::string str2("micro");
  std::string& strs = str1;
  std::string* ptrs = &str1;
  strs = str2;
  ptrs = &str2;
  A.strs = micro, * ptrs = micro
  B.strs = micro, * ptrs = trend
  C.strs = trend, * ptrs = micro
  D.strs = trend, * ptrs = trend
  正确答案：A
5.#define MUL(A,B) A*B 请问MUL(3+4,5+6)的值是多少？ 
  正确答案: 3+4*5+6=29 
6.struct name1{ char str; int num;  short x;}；求sizeof(name1)是多少？是在32位处理器上  
  正确答案: 12，注意内存对齐，char占1byte但Int要在4的整数倍上，同样short要在2的整数倍上，但同样要内存对齐。
7.int main(){  int x=3;  printf("%d",x);   return 1;}问题：main函数既然不会被其它函数调用，为什么要返回一个值？这个返回值有什么用途？  
  正确答案: 操作系统需要这个返回值，main函数的返回值用于说明程序的退出状态。如果返回0，则代表程序正常退出；返回其它数字的含义则由系统决定。通常，返回            非零代表程序异常退出。
8.typedef union{ int ia; char c[4]; short int s[2]; }untest; 
  untest un;  un.c[0]=0xAA;un.c[1]=0xBB; un.c[2]=0xCC;un.c[3]=0xDD; 
  那么un.ia=? un.s[0]=? 注意，X86CPU是小端结尾的.
  正确答案: un.ia=0xDDCCBBAA; un.s[0]=0xBBAA; 将低序字节存储在起始地址，这称为小端(little-endian)字节序 （低地址放小的，小端）
  S[0]存在低位字节，所以是C[0],C[1], 在内部低位字节存在C[0]是低位字节，然后C[1]是高位字节。即0xBBAA
9.char a[8]={1,2,3,4,5,6,7,8}; int *ptr=(int *)a; printf("%d，%d", *(a+1),  *(char *)(ptr+1)); 请问输出： 
  正确答案：2，5
10.关键字volatile有什么含义？并给出3个不同的例子  
  正确答案：一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。
          精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。 下面是volatile变量的几个例子：            1）. 并行设备的硬件寄存器（如：状态寄存器）  
           2）. 一个中断服务子程序中会访问到的非自动变量（Non-automatic variables)
           3）. 多线程应用中被几个任务共享的变量  
11.Linux中查看进程状态的命令有哪些？列出当前目录以及下面所有子目录里面的文件的命令是？
  正确答案：ps,top,pstree             ls -l|grep ^d, find . -type d
12.关键字static 有什么用途？（请至少说明两种）
  正确答案：1.初始化为0 2.声明模块或者函数外无法使用 3.static仅初始化一次，被声明为静态的变量在这一函数被调用过程中维持其值不变（该变量存放在静态变量区）
13.函数memset的实现 原型：void*memset(void*buffer,int c,intcount); 功能：把buffer所指内存区域的前count个字节设置成字符c。
  void*memset(void* src,int c,size_t count)
  { 
  assert(src!=NULL); 
  char*tmpsrc=(char*)src;
  while(count--)  *tmpsrc++=(char)c;  //
  return src;
  }
14. *pa++ 
  首先，后自增运算符的优先级高于解引用，因此该表达式等同于*(pa++)
  其次，后自增表示，在表达式中先使用操作数的值，此处为pa
  然后，怎样使用操作数pa的值呢（即对pa采取怎样的操作呢），解引用*，此处为*pa
  最后，所有副作用在到达下一个顺序点之前都会生效，因此*pa++可以理解为2个操作，
  先是*pa
  再是pa++
 15.多态是什么？（重写（也称为覆盖 override））
   正确答案: 多态性可以简单地概括为“一个接口，多种方法”。多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以    确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。
   C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。（这里我觉得要补充，重写    的话可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性）
   >>1、 被重写的函数不能是static的。必须是virtual的 2 、重写函数必须有相同的类型，名称和参数列表
     3 、重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public,protected也是可以的
  
 16. 重载
   >>函数名相同，函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同。函数返回值的类型可以相同，也可以不相同。发生在一个类内部。但是不能靠返回    类型来判断。
  （1）相同的范围（在同一个作用域中） ；
  （2）函数名字相同；
  （3）参数不同；
  （4）virtual 关键字可有可无。
  （5）返回值可以不同；
  
  17.重定义（也成隐藏）
  （1）不在同一个作用域（分别位于派生类与基类） ；
  （2）函数名字相同；
  （3）返回值可以不同；
  （4）参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载以及覆盖混淆） 。
  （5）参数相同，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 。（如果相同有Virtual就是重写覆盖了）。
18.结构体里默认public，类里默认private
   函数或变量的默认属性都是extern(外部链接的)

  
